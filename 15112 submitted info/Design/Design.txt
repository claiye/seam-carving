Design

The problem I am trying to solve is content-aware resizing through seam carving of any given image. The general approach I took towards this is shown in SeamCarvingGUI.py. Firstly, the energy of each pixel in the image is calculated using the dual gradient energy function, which compares the pixels immediately left and right, up and down of the current pixel to each other and find its difference. Then the entire matrix is recalculated. For each row starting from the second, each pixel checks the pixels above it (left, center, and right) and adds the one with least energy to the pixel’s current energy. Please refer to LeastEnergyPath.png for an illustration of what the algorithm does. Once the entire matrix runs through that, the last row contains the values of seams with least energy required to reach each pixel in the last row. Then, using the value in the last row with the least energy, the entire seam with least energy is found by tracing all the way back up. The seam is stored as a list of (row, col) tuples, which is removed from the list of pixels in the image.

Once the seam has been removed, the entire matrix need to be recalculated because the pixels that immediately surrounded the seam now have a new energy value, and because of that, a entire cascade of new seams have to be calculated. Firstly, using the (row, col) information of the seam that was just removed, all the pixels that were immediately around it have a new energy value assigned to it. Then, starting from the top row, for each col that has been changed, the number of affect columns in the next row will be the same cols as the pervious row, plus one more on each side, expanding like a tree until it reaches the sides of the picture. Every pixel within that tree has a new seam value recalculated according to the same algorithm said above. This must be done because, when calculating seams, each value depends on three values above it, and if any of those values change, it is very likely that the value in the succeeding row has changed. The tree grows in two directions, either away from each other (when the pixel removed in the seam in the first row is not on either side of the image) or towards each other (when the pixel removed in the seam in the first row is on either side of the pixel, which affects the energy of the pixel on the other side, as dual gradient energy function wraps around the image). 

The algorithm repeats itself for however many seams that need to be carved.

Once there is a finish product, it is also possible to draw the seams that were carved as red lines back on to the image. To do so, append each removed seam to a list. At the end, iterate through it backwards, and insert (255, 0, 0) at each location. 

For the user, the experiences comes from choosing what image to carve, what dimensions to carve to, and seeing exactly what the algorithm carves. 

The modules that have been used include tkinter, PIL, and threading. Tkinter is needed for user to be able to see and interact with carving. PIL includes Image and ImageTk. Image is the backend to the interaction that the user does with the image, and can rotate, crop, open, and save images as needed. Threading was used only for the mode where the backend carves the image and the screen displays how much carving has been done. Threading was used here because the seam carving algorithm is rather costly and time-consuming, and because it cant instantaneously carve something and the canvas doesn’t redraw until it finishes. 

The interface of this app has been kept very minimalistic for the sake of simplicity. The user should be focused on the image that it’s interacting with, not anything else. The editor part of the app was made into a floating window for the same purpose. 